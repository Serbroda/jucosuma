// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: contracts.sql

package sqlc

import (
	"context"
	"time"
)

const deleteContractSoft = `-- name: DeleteContractSoft :exec
;

UPDATE contracts
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) DeleteContractSoft(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteContractSoft, id)
	return err
}

const findAllContracts = `-- name: FindAllContracts :many
;

SELECT id, name, company, contract_type, category, start_date, end_date, contract_number, customer_number, contract_holder, costs, billing_period, contact_person, contact_address, contact_phone, contact_email, icon_source, notes, created_at, updated_at, deleted_at
FROM contracts
WHERE deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) FindAllContracts(ctx context.Context) ([]Contract, error) {
	rows, err := q.db.QueryContext(ctx, findAllContracts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Company,
			&i.ContractType,
			&i.Category,
			&i.StartDate,
			&i.EndDate,
			&i.ContractNumber,
			&i.CustomerNumber,
			&i.ContractHolder,
			&i.Costs,
			&i.BillingPeriod,
			&i.ContactPerson,
			&i.ContactAddress,
			&i.ContactPhone,
			&i.ContactEmail,
			&i.IconSource,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findContractById = `-- name: FindContractById :one
;

SELECT id, name, company, contract_type, category, start_date, end_date, contract_number, customer_number, contract_holder, costs, billing_period, contact_person, contact_address, contact_phone, contact_email, icon_source, notes, created_at, updated_at, deleted_at
FROM contracts
WHERE id = ?
  AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) FindContractById(ctx context.Context, id int64) (Contract, error) {
	row := q.db.QueryRowContext(ctx, findContractById, id)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.ContractType,
		&i.Category,
		&i.StartDate,
		&i.EndDate,
		&i.ContractNumber,
		&i.CustomerNumber,
		&i.ContractHolder,
		&i.Costs,
		&i.BillingPeriod,
		&i.ContactPerson,
		&i.ContactAddress,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.IconSource,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findContractHolders = `-- name: FindContractHolders :many
;

SELECT DISTINCT contract_holder
FROM contracts
WHERE deleted_at IS NULL
  AND contract_holder IS NOT NULL
ORDER BY contract_holder ASC
`

func (q *Queries) FindContractHolders(ctx context.Context) ([]*string, error) {
	rows, err := q.db.QueryContext(ctx, findContractHolders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*string
	for rows.Next() {
		var contract_holder *string
		if err := rows.Scan(&contract_holder); err != nil {
			return nil, err
		}
		items = append(items, contract_holder)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertContract = `-- name: InsertContract :one
INSERT INTO contracts (created_at,
                       updated_at,
                       name,
                       company,
                       contract_type,
                       category,
                       start_date,
                       end_date,
                       contract_number,
                       customer_number,
                       contract_holder,
                       costs,
                       billing_period,
                       contact_person,
                       contact_address,
                       contact_phone,
                       contact_email,
                       icon_source,
                       notes)
VALUES (CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17) RETURNING id, name, company, contract_type, category, start_date, end_date, contract_number, customer_number, contract_holder, costs, billing_period, contact_person, contact_address, contact_phone, contact_email, icon_source, notes, created_at, updated_at, deleted_at
`

type InsertContractParams struct {
	Name           string     `db:"name"`
	Company        *string    `db:"company"`
	ContractType   string     `db:"contract_type"`
	Category       string     `db:"category"`
	StartDate      time.Time  `db:"start_date"`
	EndDate        *time.Time `db:"end_date"`
	ContractNumber *string    `db:"contract_number"`
	CustomerNumber *string    `db:"customer_number"`
	ContractHolder *string    `db:"contract_holder"`
	Costs          *float64   `db:"costs"`
	BillingPeriod  string     `db:"billing_period"`
	ContactPerson  *string    `db:"contact_person"`
	ContactAddress *string    `db:"contact_address"`
	ContactPhone   *string    `db:"contact_phone"`
	ContactEmail   *string    `db:"contact_email"`
	IconSource     *string    `db:"icon_source"`
	Notes          *string    `db:"notes"`
}

func (q *Queries) InsertContract(ctx context.Context, arg InsertContractParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, insertContract,
		arg.Name,
		arg.Company,
		arg.ContractType,
		arg.Category,
		arg.StartDate,
		arg.EndDate,
		arg.ContractNumber,
		arg.CustomerNumber,
		arg.ContractHolder,
		arg.Costs,
		arg.BillingPeriod,
		arg.ContactPerson,
		arg.ContactAddress,
		arg.ContactPhone,
		arg.ContactEmail,
		arg.IconSource,
		arg.Notes,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.ContractType,
		&i.Category,
		&i.StartDate,
		&i.EndDate,
		&i.ContractNumber,
		&i.CustomerNumber,
		&i.ContractHolder,
		&i.Costs,
		&i.BillingPeriod,
		&i.ContactPerson,
		&i.ContactAddress,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.IconSource,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateContractById = `-- name: UpdateContractById :exec
;

UPDATE contracts
SET name            = ?1,
    company         = ?2,
    contract_type   = ?3,
    category        = ?4,
    start_date      = ?5,
    end_date        = ?6,
    contract_number = ?7,
    customer_number = ?8,
    contract_holder = ?9,
    costs           = ?10,
    billing_period  = ?11,
    contact_person  = ?12,
    contact_address = ?13,
    contact_phone   = ?14,
    contact_email   = ?15,
    icon_source     = ?16,
    notes           = ?17,
    updated_at      = CURRENT_TIMESTAMP
WHERE id = ?18
  AND deleted_at IS NULL
`

type UpdateContractByIdParams struct {
	Name           string     `db:"name"`
	Company        *string    `db:"company"`
	ContractType   string     `db:"contract_type"`
	Category       string     `db:"category"`
	StartDate      time.Time  `db:"start_date"`
	EndDate        *time.Time `db:"end_date"`
	ContractNumber *string    `db:"contract_number"`
	CustomerNumber *string    `db:"customer_number"`
	ContractHolder *string    `db:"contract_holder"`
	Costs          *float64   `db:"costs"`
	BillingPeriod  string     `db:"billing_period"`
	ContactPerson  *string    `db:"contact_person"`
	ContactAddress *string    `db:"contact_address"`
	ContactPhone   *string    `db:"contact_phone"`
	ContactEmail   *string    `db:"contact_email"`
	IconSource     *string    `db:"icon_source"`
	Notes          *string    `db:"notes"`
	ID             int64      `db:"id"`
}

func (q *Queries) UpdateContractById(ctx context.Context, arg UpdateContractByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateContractById,
		arg.Name,
		arg.Company,
		arg.ContractType,
		arg.Category,
		arg.StartDate,
		arg.EndDate,
		arg.ContractNumber,
		arg.CustomerNumber,
		arg.ContractHolder,
		arg.Costs,
		arg.BillingPeriod,
		arg.ContactPerson,
		arg.ContactAddress,
		arg.ContactPhone,
		arg.ContactEmail,
		arg.IconSource,
		arg.Notes,
		arg.ID,
	)
	return err
}
